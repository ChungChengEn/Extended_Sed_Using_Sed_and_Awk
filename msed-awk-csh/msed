#!/usr/bin/csh
#Save the piped-in input into a file:
cat > t4

#Create a file and put $1 into it, but also add a space in front of it. (The
#space is added so that line 17 below is facilitated. Further, see footnote 1
#for information on why it is argument 1 that gets put into the file):
echo \ $1:q > t5

#Loop through all of the passed-in arguments except for the first argument:
foreach i ( "`seq $# -1 2`" )
   #Within the t5 file, iteratively look for the $2, then the $3, etc.
   #If you find a match, create a new file t6, where the argument is replaced
   #by the actual argument value. 
   cat t5 | awk '/\\\\/{gsub(/\\\\/,"\a");}/[^\\]\$/{temp=$0;while(temp~"[^\\\\]\\$'$i'"){ind=match(temp,"[^\\\\]\\$'$i'");c=substr(temp,ind,1);sub(c "\\$" "'$i'", c "'$argv[$i]'");temp=$0}}/\\\$/{temp=$0;while(temp~"\\\\\\$'$i'"){sub("\\\\\\$'$i'","$'$i'");temp=$0}}1' > t6
   #Now move t6 back to t5, so that we are ready to set up the next argument.
   mv t6 t5
   #Since we're done processing this argument, remove it from argv, but not if
   #it's a flag that starts with a "-" (but remember that Cshell if-conditions
   #have a problem to overcome, when testing things that start with a "-").
   if ( X$argv[$i] !~ "X-*" ) set argv[$i] = ""
end

#Now we want to use almost every ";" into a line separation.
#   A line separator? Yes: The ";" becomes "\n;"
#   Almost every? Yes: because we DON'T want to do it for "\;". (See footnote
#   3 in the README file for more info on our strategy in handling backquoting
#   and also its limitations.)
#We also want to get rid of the space added by line 8, above:
#And we want to prevent any "\" that is itself backquoted (\\) from being used
#to backquote anything else. This is handled by turning them into "\a"s. 
cat t5 | awk '{sub(/^ */,"")}/\\;/{gsub(/\\;/,"\f")}/;/{gsub(/;/,"\n;")}1' > t6

#Create an awk file from the part of this file below the exit:
awk '/^exit/,0{if($0~"^exit"){next}print}' < msed > t7

#Use the awk program created on line 35, above, in order to process the file
#created on line 32 above (which, you will recall, is derived from argument 1,
#which is the msed program the user has provided):
cat t6 | awk -ft7 > t8

#Here are some initializations to set up the foreach loop that will follow:
rm -f t9
@ cnt = 0
@ z = 0

#Go through the version of sed commands stored in t8 (created from Line 40
#above), to see if any of the commands used a $-# syntax or a "f" or "F":
foreach x ( "`cat t8`")
   #Here, x is a single line from t8, so it is usually a single sed command.
   #Now we want to make a variable y that will be the number # of any $-# that
   #might be on this line x. (Let y be "" otherwise.):
   set y = `echo $x:q | awk '/\v[0-9]+/{ind=match($0,"\\v[0-9]+");temp=substr($0,ind+1);first_non_digit=match(temp,"[^0-9]");number=substr(temp,1,first_non_digit-1);printf("%d",number)}'` # there will be a not-completely-convert warning --> not possible to solve
   
   #So now, what if $y==a number? Well that means that we need to work out
   #what line number would match to $#-1? Set z to that line number:
   if ( X$y != X ) @ z = `cat t4 | wc -l` - $y
   
   #So now we take the single line $x and clean it up. The $-# will turn into
   #the number $z. Also to fix: make the branches used for "F" unique, by
   #adding a counter number to the end of whateven branch label may be in #x.
   echo $x:q | awk '{sub(/\$-\v'$y'/,"'$z'");gsub(/label7/,"label7" "'$cnt'");gsub(/flagL1/,"flagL1" "'$cnt'");gsub(/flagL2/,"flagL2" "'$cnt'")}1' >> t9

   #Increase the counter used for the branch labels on line 63, above:
   @ cnt = $cnt + 1
end

#Line 62 above created t9, the ordinary sed implementation of the original
#program the user had provided in $1. So we replace $1 with t9:
set argv[1] = -ft9

#Line 3 had captured the piped-in input into t4. So we now process it:
cat t4 | sed $*:q

#And now we are done with cshell:
exit 0
#The rest of this file is awk code (see line 35, above)
#The _________ sections below are followed by ..., because you are allowed to
#use as many lines as you want to implement these parts.
#
#
#The section below here puts individual sed commands on individual lines.
#The issue is to clean up "y", "s", or "\" commands, because these commands
#can have ";" inside them - and if they did have ";", then these ";" will have
#caused line separations on Line 32, above. We need to recogize if the current
#line _starts with a "y", "s", "/", or "\" *and* is incomplete. In that case,
#bring in additional line(s), until the full command is on one line.
#Note: This is a full section using multiple branches.
#Note: This section is as many lines as you need.
#Note: All of the following should get pulled into one line each:
#      s/;/;/  or  s;a;b;  or  y;,\;;\;,;  or  \;a;b;  or  /;;/p   or   etc.
#Note: But, to keep things simple, we won't worry about: "[;]".
#Note: In our new version of sed, we like the fact that ";" will cause breaks
#      for i, a, c, C, w, W, r.

#This section combines lines to form /.../ or \x...x -- if there are ; in it:
/^[;]?\//{temp=$0;while(temp !~ "^[;]?/.*[^\\\\]/"){getline x;$0=$0 x;temp=$0}}
/^[;]?\\./{ind=match($0,"\\\\.");c=substr($0,ind+1,1);temp=$0;while(temp !~ "^[;]?\\\\" c ".*[^\\\\]" c){getline x;$0=$0 x;temp=$0}}
/^[;]?\f/{temp=$0;while(temp !~"^[;]?\f.*[^\\\\];"){getline x;$0=$0 x;temp=$0}}



#Now we consider ", /.../" or ", \x...x" since these can have ;
#Step 1 is to mark off the part that might go before the , by using a \v
/^[;]?\/.*[^\\]\//{first=match($0,"/");temp=substr($0,first+1);first_unescaped=match(temp,"[^\\\\]/");end_predication=first+first_unescaped+1;temp=substr($0,end_predication+1);spaces_follows=(match(temp,"[^ ]")>0)? match(temp,"[^ ]")-1:length(temp);$0=substr($0,1,end_predication+spaces_follows) "\v" substr($0,end_predication+spaces_follows+1);}
/^[;]?\\./{ind=match($0,"\\\\.");c=substr($0,ind+1,1);first=match($0,c);temp=substr($0,first+1);first_unescaped=match(temp,"[^\\\\]" c);end_predication=first+first_unescaped+1;temp=substr($0,end_predication+1);spaces_follows=(match(temp,"[^ ]")>0)? match(temp,"[^ ]")-1:length(temp);$0=substr($0,1,end_predication+spaces_follows) "\v" substr($0,end_predication+spaces_follows+1);}
/^[;]?\f.*[^\\];/{first=match($0,"\f");temp=substr($0,first);first_unescaped=match(temp,"[^\\\\];");end_predication=first+first_unescaped;$0=substr($0,1,end_predication) "\v" substr($0,end_predication+1);}
/^[;]?[0-9]+ */{first=match($0,"[^0-9 ;]");$0=substr($0,1,first-1) "\v" substr($0,first);}
/^[;]?\$[^-]/{first=match($0,"[^ ;$]");$0=substr($0,1,first-1) "\v" substr($0,first);}
/^[;]?\$-/{ind=match($0,"-");temp=substr($0,ind+1);first_non_digit=match(temp,"[^0-9]");end_predication=ind+first_non_digit-1;temp=substr($0,end_predication+1);spaces_follows=(match(temp,"[^ ]")>0)? match(temp,"[^ ]")-1:length(temp);$0=substr($0,1,end_predication+spaces_follows) "\v" substr($0,end_predication+spaces_follows+1);}
/\v, *\//{temp=$0;while(temp !~ "\\v, */.*[^\\\\]/"){getline x;$0=$0 x;temp=$0}}
/\v, *\\./{ind=match($0,"\\v, *\\\\.");temp=substr($0,ind+2);ind2=match(temp,"\\\\.");c=substr(temp,ind2+1,1);temp=substr(temp,ind2);while(temp !~ "^\\\\" c ".*[^\\\\]" c){getline x;$0=$0 x;temp=temp x;}}
/\v, *\f/{ind=match($0,"\\v, *\\f");temp=substr($0,ind+2);first=match(temp,"\\f");temp=substr(temp,first);while(temp !~ "^\\f.*[^\\\\];"){getline x;$0=$0 x;temp=temp x;}}

#above implementation were finished (need double check) 


#Now put a \v after whatever predication may be given (including none)
/\v, *\\./{ind=match($0,"\\v, *\\\\.");$0=substr($0,1,ind-1) substr($0,ind+1);temp=substr($0,ind+1);first_not_space=match(temp,"[^ ]");temp=substr(temp,first_not_space);ind2=match(temp,"\\\\.");c=substr(temp,ind2+1,1);temp=substr(temp,ind2+2);first_unescaped=match(temp,"[^\\\\]" c);end_predication=ind+first_not_space+ind2+first_unescaped+1;temp=substr($0,end_predication+1);spaces_follows=(match(temp,"[^ ]")>0)? match(temp,"[^ ]")-1:length(temp);$0=substr($0,1,end_predication+spaces_follows) "\v" substr($0,end_predication+spaces_follows+1);}
/\v, *\/.*[^\\]\//{ind=match($0,"\\v, */.*[^\\\\]/");$0=substr($0,1,ind-1) substr($0,ind+1);temp=substr($0,ind+1);first_not_space=match(temp,"[^ ]");temp=substr(temp,first_not_space);first=match(temp,"/");temp=substr(temp,first+1);first_unescaped=match(temp,"[^\\\\]/");end_predication=ind+first_not_space+first_unescaped+1;temp=substr($0,end_predication+1);spaces_follows=(match(temp,"[^ ]")>0)? match(temp,"[^ ]")-1:length(temp);$0=substr($0,1,end_predication+spaces_follows) "\v" substr($0,end_predication+spaces_follows+1);}
/\v, *\f.*[^\\];/{ind=match($0,"\\v, *\\f.*[^\\\\];");$0=substr($0,1,ind-1) substr($0,ind+1);temp=substr($0,ind+1);first_not_space=match(temp,"[^ ]");temp=substr(temp,first_not_space);first=match(temp,"\\f");temp=substr(temp,first+1);first_unescaped=match(temp,"[^\\\\];");end_predication=ind+first_not_space+first_unescaped+1;temp=substr($0,end_predication+1);spaces_follows=(match(temp,"[^ ]")>0)? match(temp,"[^ ]")-1:length(temp);$0=substr($0,1,end_predication+spaces_follows) "\v" substr($0,end_predication+spaces_follows+1);}
/\v, *[0-9]+/{ind=match($0,"\\v, *[0-9]+");$0=substr($0,1,ind-1) substr($0,ind+1);temp=substr($0,ind+1);first_not_space=match(temp,"[^ ]");temp=substr(temp,first_not_space);first_non_digit=match(temp,"[^0-9]");end_predication=ind+first_not_space-1+first_non_digit-1;temp=substr($0,end_predication+1);spaces_follows=(match(temp,"[^ ]")>0)? match(temp,"[^ ]")-1:length(temp);$0=substr($0,1,end_predication+spaces_follows) "\v" substr($0,end_predication+spaces_follows+1);}
/\v, *\$[^-]/{ind=match($0,"\\v, *\\$");$0=substr($0,1,ind-1) substr($0,ind+1);temp=substr($0,ind+1);first_not_space=match(temp,"[^ ]");temp=substr(temp,first_not_space);first=match(temp,"\\$");end_predication=ind+first_not_space;temp=substr($0,end_predication+1);spaces_follows=(match(temp,"[^ ]")>0)? match(temp,"[^ ]")-1:length(temp);$0=substr($0,1,end_predication+spaces_follows) "\v" substr($0,end_predication+spaces_follows+1)}
/\v, *\$-/{ind=match($0,"\\v, *\\$");$0=substr($0,1,ind-1) substr($0,ind+1);temp=substr($0,ind+1);first_not_space=match(temp,"[^ ]");temp=substr(temp,first_not_space);first=match(temp,"\\$");temp=substr(temp,first+2);first_non_digit=match(temp,"[^0-9]");end_predication=ind+first_not_space+first_non_digit;temp=substr($0,end_predication+1);spaces_follows=(match(temp,"[^ ]")>0)? match(temp,"[^ ]")-1:length(temp);$0=substr($0,1,end_predication+spaces_follows) "\v" substr($0,end_predication+spaces_follows+1)}
!/\v/{semi=match($0,"^;");temp=substr($0,semi+1);leading_space=(match(temp,"[^ ]")>0)? match(temp,"[^ ]")-1:length(temp);$0=(leading_space>0)?substr($0,1,semi+leading_space) "\v" substr($0,semi+leading_space+1):((semi>0)? ";\v" substr($0,2):"\v" $0)}


#Now deal with y and s comands that might use ";"
/\v{[ys]/{ind=match($0,"\\v{[ys]");c=substr($0,ind+2,1);sub(/\v{[ys]/,"\v{\v" c)}   #<new1>
/\v[ys]$/{getline x;$0=$0 x}
/\v[ys]./{ind=match($0,"\\v[ys].");$0=substr($0,1,ind-1) substr($0,ind+1);temp=substr($0,ind);c=substr(temp,2,1);while(temp !~ "^[ys]" c ".*[^\\\\]" c ".*[^\\\\]" c && temp !~ "^[ys]" c c c && temp !~ "^[ys]" c c ".*[^\\\\]" c && temp !~ "^[ys]" c ".*[^\\\\]" c c ){getline x;$0=$0 x;temp=temp x;}}




#
#So now we have whole sed commands on lines. By I am adding a new part here:
#If the line uses a "{",then put what comes after the { to the next line.
#So "/x/{p"    =>  print("/x/{");$0="p"
#So "1,/x/{"   =>  print("1,/x/{");$0=""
#So "{="       =>  print("{");$0="="
#So "s{x{y{g"  =>  No change.
/^;/{sub(/^;/,"")}
/^\$-/{sub(/^\$-/,"$-\v")}  # add \v beforehand to make sure all $0 beginning with \$ will be processed. Even if $0 has been change in the next command
/, *\$-/{ind=match($0,", *\\$-");str1=substr($0,1,ind);temp=substr($0,ind+1);first_not_space=match(temp,"[^ ]");str2=(first_not_space-1>0)? substr(temp,1,first_not_space-1):"";temp=substr(temp,first_not_space);sub(/^\$-/,"$-\v",temp);str3=temp;$0=str1 str2 str3;}
/\v{/{ind=match($0,"\\v{");$0=substr($0,1,ind-1) substr($0,ind+1);ind_open_braces=match($0,"{");print substr($0,1,ind_open_braces);$0=(ind_open_braces+1<=length($0))? substr($0,ind_open_braces+1):"";}
/\v/{gsub(/\v/,"")}




#Complete the lines below to handle the cases of Z, W, D, C, f, and F. This
#time I require that you not break the hold space or flags that the user's
#msed program is using. (That is: you saw how my solution on the last homework
#had logic to keep your code from breaking the hold space or the flag state;
#this homework must retain that.)
{flag_control=0}
/^[ZCWD]/{flag_control=1;print "TflagL1; x; s/$/\\r\\v/; x; :flagL1"}
/^[^ZCWD]/{flag_control=0;}
/^Z/{sub(/^Z/,"s/[^\\n]*\\n\\{,1\\}//")}
/^C/{ind=match($0,"^C");temp=substr($0,ind+1);sub(/.*/,"s/.*/" temp "/")}
/^W/{ind=match($0,"^W");filename=substr($0,ind+1);sub(/.*/,"{s/.*/\\v\\&/;H;s/\\n.*//;s/\\v//;w" filename "\ng;s/\\n\\v.*//;x;s/.*\\v//}")}
/^D/{sub(/^D/,"{/\\n/!s/.*/\\&\\n/;D;}")}
/^f/{sub(/^f/,"s/.*/\\&/")}
/^F/{sub(/^F/,"tlabel7;:label7")}


#These add an unusual symbol ("\v", which doesn't occur in the input) to mark
#out the $-#, so that line 63 above can find them and convert them:
/^\$-[^\v]/{sub(/^\$-/,"$-\v")} # add \v if we don't have it yet
/, *\$-[^\v]/{ind=match($0,", *\\$-");str1=substr($0,1,ind);temp=substr($0,ind+1);first_not_space=match(temp,"[^ ]");str2=(first_not_space-1>0)? substr(temp,1,first_not_space-1):"";temp=substr(temp,first_not_space);sub(/^\$-/,"$-\v",temp);str3=temp;$0=str1 str2 str3;}


#These clean up the backquotes:
/\f/{gsub(/\f/,"\\;")}
/\a/{gsub(/\a/,"\\\\")}
1
flag_control{print "TflagL2; :flagL2; x; s/\\r\\v$//; x"}